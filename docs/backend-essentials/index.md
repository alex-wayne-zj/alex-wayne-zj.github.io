---
title: 后端知识库
date: 2022-11-03
cover: "./cover.jpg"
tags: 
  - 面试
  - 后端
  - 职业技能
description: "More than RESTful/RPC API."
---

## OS-基础

操作系统是计算机硬件和应用软件的中间层系统软件。主要功能包括**进程管理、内存管理、文件系统管理、设备管理**等

虚拟机将计算机虚拟到硬件层；容器只虚拟到操作系统以上的软件层。

```bash
# Linux常见命令
# 状态
top
# 查看CPU核心总数
nproc
ps aux | grep
# 可与grep配合查看某端口连接数和状态
netstat
ping
ifconfig
wget
kill -9 PID
df
# 显示目录磁盘使用情况
du
# 显示内存和交换空间使用情况
free
# 文件相关
pwd
mkdir
rm
mv
# rwxa421ugo
chmod
find . -name "a.txt"
unzip
tar
# 定期执行指定命令，并将结果实时显示到终端中，默认2秒1次
# 可与netstat结合查看特定端口qps
watch
```

多路复用：通过单个线程同时监控多个I/O流，通过就绪通知避免阻塞等待

Linux I/O多路复用的三种机制

* select：fd_set（bit_map）数组存储文件描述符集合，select内核会遍历fd。（文件描述符最大1024，用户态拷贝到内核态）
* poll：poll_fd（结构体数组，大小理论上仅受机器内存限制）链表存储文件描述符集合，同样需要拷贝和遍历，但文件描述符不限
* epoll（目前Linux使用）：使用 `epoll_wait` 等待文件描述符就绪，内核通过回调机制直接通知就绪的文件描述符（有通知一次（边缘触发）和一直通知（水平触发）的区别）。文件描述符数量没有限制（红黑树存储），内存映射（mmap），减少用户态和内核态的拷贝

Load Average：反映系统负载，一段时间内平均有多少个正在处理和等待被调度的进程（过去1min, 5min, 15min）大于CPU核心数则意味着系统繁忙

内核类型

* 宏内核：功能集成，如Linux。性能高但复杂性高
* 微内核：仅保留核心功能在内核（基本的进程和内存管理），其他在用户态运行，用IPC通信。如Windows。性能低但安全稳定

## OS-进程管理

进程是操作系统分配资源的基本单位，线程是CPU调度的基本单位。一个进程可以包含多个线程，线程共享进程的资源（代码、堆空间），每个线程有自己的寄存器和运行栈

进程间通信方式（Inter-Process Communication, IPC）：管道、消息队列、共享内存、信号量、套接字、信号

PCB(Process Control Block)：进程控制块，OS用于管理进程的数据结构（进程ID、状态、程序计数器、CPU寄存器等）

进程状态：创建、结束、就绪、运行、阻塞

线程同步方式：信号量、互斥锁、管道

孤儿进程：父进程退出，子进程还在运行，它们将被init进程回收（Linux中可以用top命令查找）

僵尸进程：子进程退出，父进程没有用wait/waitpid获取子进程状态，进程描述符仍然存在（Linux中可以用top命令查找）。

守护进程：在后台运行的进程，通常用于提供服务

并发和并行：并发表示一段时间内多个任务都会被切换处理；并行则是真正的多任务同时执行

常见进程调度算法：先来先服务、短作业优先、时间片轮转、优先级调度、多级反馈队列调度（目前使用）

临界区是访问共享资源的代码段

死锁条件：互斥、占有并保持、非抢占条件、循环等待。避免死锁：设置资源有序分配，设置超时让出等

> 举例：哲学家就餐问题

同步和异步：顺序执行和并发执行

有了进程为什么还要有线程：如果只有进程阻塞后就没法提供其他服务了

线程间共享资源：堆区、全局变量和静态变量、文件等

线程上下文：栈区指针、寄存器、程序计数器

* 使用多进程情况：高隔离性，CPU密集型
* 使用多线程情况：快速切换，I/O密集型

## OS-内存管理

内核态和用户态能访问的地址空间不同（前者全部、后者部分）安全考虑

用户态切换到内核态：系统调用、异常、外部中断

系统调用是应用程序请求操作系统服务的接口，如文件操作、进程管理、网络通信等(fork, open, read, write)

用户进程地址空间分为代码段、数据段、堆栈段。

内部内存碎片（分配内存未完全使用） & 外部内存碎片（分配内存块有间隙）

页面置换算法：FIFO(First-In First-Out), LRU(Least Recently Used)最近最久未使用（应用较多）, LFU(Least Frequently Used)使用频率最少

虚拟内存作用：

* 提供超过系统物理内存的可用内存，部分内存与磁盘互换（缺页中断）
* 隔离进程，提高内存使用安全性，防止操作到系统运行必需内存
* 提高内存利用率，仅加载一份操作系统动态库，仅将进程正在使用的数据和指令载入物理内存

> 页表的存储和管理需要占用一定的内存空间；地址转换过程增加了系统的开销。
>
> 多级页表能减少内存占用，提高访问效率
>
> TLB就是页表的缓存，利用了时空局部性

MMU(Memory Management Unit)：负责虚拟地址和物理地址之间的映射关系

* 分段
  * 段大小不等，且有实际意义：主程序段、栈段、子程序段等等，容易导致外部碎片
  * 虚拟地址：段号+段内偏移量；segment table: 段号+该段起始物理地址
* 分页（流行）
  * 为防止页表过大，一般采用多级页表（64位系统为四级页表），用时间换空间。
  * 分页可能出现内部碎片
  * TLB(Translation Lookaside Buffer)：利用局部性的快表
* 段页：先按段划分再按页划分。分页是为了提高内存利用率实现虚拟内存；分段是便于程序独立

## OS-文件系统管理

软链接：快捷方式，指向文件地址；硬链接：inode信息，实质是文件别名，修改会同步。

磁盘调度算法：先来先服务；最短寻道时间优先；扫描；循环扫描（只按照一个方向）；LOOK（提前结束扫描）；C-LOOK

文件系统在磁盘中的组织结构：（不同文件系统FAT32/ext4/NTFS细节不一样）

* 超级块：磁盘起始位置，全局信息，文件系统类型、大小、块大小、空闲块数量
* 目录结构：存储文件名与Inode的映射关系。
* 空闲空间管理：位图或者空闲块链表
* Inode：存储文件或目录的元数据，支持硬链接
* 数据块：4KB一块
* 日志：记录文件系统的操作日志，用于崩溃恢复。

## 计网-基础

OSI模型：七层网络模型，包括物理层（报头和起始帧分界符 & 检测错误的帧校验序列）、数据链路层（交换机，MAC地址）、网络层、传输层、会话层、表示层（数据转换压缩和加密）和应用层。（理论模型）

> 交换机端口不具有MAC地址，MAC地址表记录LAN中MAC地址和交换机端口的映射关系
>
> 路由器各个端口都有MAC地址的IP地址，相当于网卡，发送时会替换MAC地址，但IP地址不变

TCP/IP模型：四层模型，包括网络接口层（Ethernet/WiFi, 48位MAC包头）、网际层（IP）、传输层（TCP/UDP）和应用层。（实际应用模型）

从上至下层层封装，从下至上层层解封

> 常见应用层服务：HTTP80, HTTPS443, DNS53, FTP21, SSH22

TCP是面向连接的协议，面向字节流（会分段），提供可靠的数据传输，保证数据顺序和完整性；UDP是无连接的协议，面向报文段（只加UDP头），传输速度快但不保证可靠性（直播、视频、电话等）。

> 让UDP可靠：应用层重现TCP功能，序列号、ACK、超时重传
>
> TCP首部没有数据长度字段（面向字节流），IP和UDP有

> * 流量控制：确保发送方的发送速率不会超过接收方的处理能力。通过滑动窗口协议的窗口大小控制
> * 拥塞控制：防止网络中因为报文过多而拥塞。通过拥塞窗口和算法（慢启动、拥塞避免、快速重传、快速恢复）控制
>   * 快速重传：收到三个及以上重复ACK即认为报文丢失，而非等到超时
>   * 快速恢复：快速重传后，拥塞窗口减半，线性增长

TCP的三次握手和四次挥手

- **三次握手**：客户端发送SYN，服务器回复SYN-ACK，客户端发送ACK和数据，建立连接。确保双方的发送和接收能力正常，防止已失效的连接请求到达服务器
  - 握手时状态：CLOSED, LISTEN, SYN_SENT, SYN_RCVD, ESTABLISHED

- **四次挥手**：客户端发送FIN，服务器回复ACK，服务器发送FIN，客户端回复ACK，关闭连接。全双工协议，双方需要分别关闭自己的发送和接收通道。
  - 服务器收到关闭连接请求进入的CLOSED_WAIT状态，是为了保证数据传完
  - 最后客户端需要等待2MSL（TIME_WAIT状态）再进入CLOSED状态，防止ACK服务器未收到需要重传
  - 挥手时状态：FIN_WAIT1, CLOSED_WAIT, FIN_WAIT2, LAST_ACK, TIME_WAIT, CLOSE

## 计网-HTTP

HTTP状态码

* 1xx：服务器收到请求，但需要进一步操作
* 2xx：请求成功处理
* 3xx：重定向
* 4xx：客户端错误
* 5xx：服务端错误

URL时URI的子集

* HTTP1.0默认短连接，引入缓存控制Expire头
* HTTP1.1默认长连接（Connection: keep-alive），range头部允许返回部分资源
* HTTP2.0默认多路复用（最广泛，一个TCP连接允许多个HTTP连接），通过request id区分，基于二进制和头部压缩，服务器推送等功能
* HTTP3基于UDP的QUIC协议

> HTTP无状态：请求之间独立，状态由cookie / session / token保存
>
> * cookie：保存在客户端浏览器的小块数据（长时间）最多4K，在请求头Cookie字段中，自动发送
>   * 广告商在页面嵌入脚本设置了第三方Cookie，同步到广告网络中实时竞价；或不同平台与广告商有信息共享机制
> * session：服务器记录的一次会话（短时间）可以放在参数或header中
> * token：保存在内存中，手动发送，相比cookie不易受CSRF攻击

反向代理是服务器端代理，接收客户端请求并转发到后端服务器，隐藏真实服务器信息。

HTTP连接池：减少频繁创建和关闭连接（TCP三次握手和四次挥手）的开销

HTTP是明文传输，HTTPS通过SSL/TLS加密传输。使用非对称加密（如RSA）交换对称加密密钥，然后用对称加密（如AES）传输数据。CA（Certificate Authority）证书防止中间人攻击

> 明文密码通过HTTPS传输是安全的（现代加密算法scrypt）



<img src="./https.webp" alt="描述" loading="lazy"/>

常见对称加密算法（使用同一密钥进行加密解密，速度快适合加密大量数据）

* AES(Advanced Encryption Standard)：密钥长度128/192/256位，应用最广泛且安全性高（TLS和磁盘加密等）
* DES：56位密钥长度，目前已不够安全，能够暴力破解
* 3DES：DES改进版，但逐渐被AES取代
* ChaCha20：Google的流加密算法，移动端性能优异

常见非对称加密算法（公钥加密私钥解密，安全性高但速度慢，适合密钥交换和数字签名）

* RSA：基于大素数的分解问题，对计算机非常困难
* ECC（Elliptic Curve Cryptography）：基于椭圆曲线离散对数问题，用于移动端加密和数字货币

> CA证书：用于验证公钥合法性和持有者身份
>
> 字段包括版本号、签名算法、颁发者、有效期、主体、公钥（最重要）、签名（验证证书真实完整）
>
> 数字签名：私钥加密，公钥验证。身份认证、数据完整、不可否认

## 计网-常见协议

DNS解析过程：浏览器缓存 → 操作系统缓存 → 本地DNS服务器 → 根域名服务器 → 顶级域名服务器 → 权威域名服务器 → HTTP请求建立TCP连接 → 服务器返回HTTP相应数据 → 浏览器解析HTML内容，构建DOM树，渲染画面

* DNS解析优化：缓存、负载均衡（多个IP）、CDN

* DNS安全问题：DNS劫持（攻击者篡改DNS解析结果，导向恶意网站）；DNS污染（伪造DNS响应干扰正常解析）；使用HTTPS防护

DNS记录类型

- **A记录**：将域名解析为IPv4地址。
- **AAAA记录**：将域名解析为IPv6地址。
- **CNAME记录**：将域名指向另一个域名（别名）。
- **MX记录**：指定邮件服务器的地址。
- **NS记录**：指定域名服务器。

IPv4和IPv6通过子网掩码划分网络地址和主机地址。

常见的负载均衡算法：轮询、加权轮询、加权随机、最少连接、IP哈希

Socket: IP + 端口 + 协议 的接口 & WebSocket: 基于TCP的应用层通信协议

从上到下：Socket库 - TCP/UDP + IP - 网卡驱动 + 网卡



抓包：Chrome console network面板，Wireshark抓包

> 幂等：对同一资源执行该操作一次和执行多次的效果相同。

CDN（内容分发网络）是将静态资源缓存到离用户更近的服务器，以加速访问。优点：加速访问、减轻源服务器压力；缺点：成本较高、缓存一致性需要管理。

常见网络攻击

* DDoS（分布式拒绝服务攻击）是通过大量请求耗尽服务器资源，使其无法正常服务，比如SYN洪泛攻击。防御：使用CDN、防火墙、限流、IP黑名单
* SQL注入攻击：通过input框输入sql脚本从而非法获取信息。防御：对用户输入进行转义

* XSS（跨站脚本攻击）是通过注入恶意脚本，窃取用户信息或劫持会话。防御：对用户输入进行转义

* CSRF（跨站请求伪造）是通过诱导访问恶意网站盗用cookie，执行未经授权的操作。防御：使用Token验证、检查Referer头

常见网络协议

* WebSocket是一种全双工通信协议，允许客户端和服务器实时通信。长连接，应用于实时场景（在线聊天、游戏、股票）

* NAT（网络地址转换）是将私有IP地址转换为公有IP地址，以解决IPv4地址不足的问题。

* VPN（虚拟专用网络）是通过加密技术在公共网络上建立私有网络，提供安全访问。
* ARP / RARP（Address Resolution Protocol）：负责IP地址和MAC地址的转换
  * `arp -a`查看本地 ARP 缓存中的 IP-MAC 映射
  * nmap扫描局域网，获取设备的 IP 和 MAC 地址
* ICMP协议：用于网络诊断（如ping协议）
* ARQ协议（Automatic Repeat-reQuest）：数据链路层和传输层的错误纠正协议，通过确认和超时机制

RESTful API是一种基于HTTP协议的API设计风格，使用HTTP方法（如GET、POST、PUT、DELETE）操作资源。

> 一般GET参数在query上不能存隐私数据，GET会被浏览器缓存，且它幂等



* 一个端口能否同时绑定TCP和UDP

可以，比如 DNS（域名系统）需要同时支持 TCP 和 UDP 查询

* 为什么有了MAC地址还需要IP地址

MAC地址是硬件地址，唯一，用于LAN中（第二层），在数据链路层中，只在LAN中有效。路由器在转发数据包时会剥离原MAC地址，改为路由器的MAC地址

IP地址是逻辑地址，可由DHCP动态分配，用于WAN中（第三层），在网络层，用于寻址、路由、分片

多线程下载数据：分块下载，HEAD请求获取文件总大小，设置Range字段指定下载字节区间

TCP粘包和拆包：多个小包可能会封装成一个，完整的包可能会拆成多个（和套接字缓冲区相关）可以设置消息边界\n

TCP报文头：源端口、目的端口、序列号、确认号、状态位、窗口大小、校验和

MTU(Maximum Transmission Unit): 一般1500字节；MSS(Maximum Segment Size): 去除IP和TCP报文头的数据最大长度

通过IP报文头的标识和分片偏移重新组合，IP分片服务于UDP，和TCP分段是两回事

LAN中防止频率碰撞：无线网中使用CSMA/CA协议载波侦听（发送前先监听）随机退避（信道繁忙则等待随机事件）确认机制（发送设备返回ACK后才确认无碰撞）

SDN：软件定义网络，将网络的控制平面（Control Plane）与数据平面（Data Plane）分离，通过集中化的控制器（Controller）来动态管理和配置网络设备。广泛应用于数据中心和网络虚拟化

TTL(Time To Live)：IP包被路由器丢弃前允许通过的最大网段数量，限制数据包的存活时间

## 软件系统-微服务

什么是微服务？

* 软件由通过明确定义的 API 进行通信的小型独立服务组成。解耦更强、易于扩展和开发

微服务缺点？

* 系统复杂性增加
* 服务间通信开销
* 分布式的一致性

微服务架构组件？

* 注册中心：用于服务的注册与发现，管理微服务的地址信息。
* 配置中心：用于集中管理微服务的配置信息，可以动态修改配置而不需要重启服务。
* 远程调用：用于在不同的微服务之间进行通信和协作。
* API 网关：作为微服务架构的入口，统一暴露服务，并提供路由、负载均衡、安全认证等功能。
* 分布式事务：保证跨多个微服务的一致性和原子性操作。
* 熔断器：用于防止微服务之间的故障扩散，提高系统的容错能力。
* 限流和降级：用于防止微服务过载，对请求进行限制和降级处理。
* 分布式追踪和监控：用于跟踪和监控微服务的请求流程和性能指标。
  * Prometheus定期拉取微服务指标，存储时间序列数据 + Grafana可视化仪表盘工具
  * ELK日志收集方案：ElasticSearch检索，Logstash收集，Kibana可视化

什么是服务发现？

* 数据库有张服务表，配合负载均衡来登记注销服务和提供服务

什么是跨域问题？

* 浏览器有同源策略作为安全机制，源：域名+协议+端口
* 本质上改后端设置CORS响应头Access-Control-Allow-Origin为*；或者使用nginx服务器，由nginx进行转发
* websocket不受同源策略限制

什么是优雅启动和停止

* 不可以关闭连接
* 新的进程启动并接管旧的进程请求
* 旧进程处理完后退出（chan通信，defer扫尾）

池化：内存池、线程池、连接池、对象池

* 创建和销毁涉及大量系统调用和网络IO
* 内存池：快速分配内存、降低内存碎片率、减少维护内存的额外空间
* 线程池：Manager, Worker, Task, TaskQueue
* 连接池：数据库连接包括TCP连接、数据库权限认证、执行语句、断开数据库连接TCP连接

消息队列：服务解耦、异步处理、流量控制

* 作为中间层，让下游服务订阅事件，把同步变成异步

> RPC(Remote Procedure Call)：远程过程调用。允许程序调用远程机器进程中的函数，就像调用本地函数一样。常用的RPC框架比如gRPC，基于HTTP/2实现，使用protobuf作为序列化机制而非json

序列化解决对象持久化和跨网络数据交换的问题：

* 文本类型：JSON/XML，可读性强，但信息密度低，占空间大
* 二进制类型：Protocol Buffer, Thrift。信息紧凑但基本不可读

TCP连接本质是操作系统内核的socket对象，一个服务器进程通常监听一个端口号，每个TCP连接需要占用一定的内存和CPU资源

流量高峰处理方案

* 云服务器水平弹性扩展，负载均衡分配到多台服务器
* 本地使用Redis缓存热点数据，CDN缓存静态资源
* 限流控制请求速率，降级在高峰期关闭非核心功能
* 耗时操作发给消息队列等待异步处理

常用限流或降级算法

* 固定时间窗口计数：无法应对突发激增流量
* 滑动窗口计数，划分时间片统计请求总和：可以应对边界激增流量（窗口快速缩小），算法需要空间容量
* 漏桶算法：服务方按固定速率从通中取请求并执行：所有请求都得等
* 令牌桶算法：维护一个固定速率添加的固定容量令牌桶，请求消耗令牌进行处理（目前使用较多）

常见设计模式（软件设计中常见问题的经典解决方案模版，相比算法描述层次更抽象）

* 单例模式：一个类只有一个实例，并提供全局访问点获取
* 工厂模式：定义一个创建对象的接口，但由子类决定实例化哪个类。
* 装饰器模式：动态地给对象添加额外的职责，而不改变其结构
* 发布订阅模式：一对多依赖关系，当一个对象改变状态时，所有依赖它的对象都会收到通知并自动更新。
* 策略模式：定义一系列算法，将每个算法封装起来，并使它们可以互相替换。

常见通信协议

* RPC（Remote Procedure Call）：让调用远程服务像调用本地函数一样
  * 基于相同的二进制协议（gRPC或Protobuf）支持双向通信，性能更优，主要用于微服务、分布式系统、实时通信
* HTTP（Hypertext Transfer Protocol）：通用数据传输，主要用于Web应用

RPC中，**存根（Stub）**是一个关键组件，用于在客户端和服务器之间进行通信和协调。存根充当了本地代理

RPC 的工作原理如下：

* 客户端程序调用客户端存根（client stub）的方法，就像调用本地方法一样。
* 客户端存根将方法调用信息（如方法名、参数等）序列化为消息，然后通过网络将消息发送给服务器端存根（server stub）。
* 服务器端存根接收到消息后，将其反序列化，然后调用相应的服务器端方法。
* 服务器端方法执行完毕，返回结果给服务器端存根。
* 服务器端存根将结果序列化为消息，然后通过网络将消息发送回客户端存根。
* 客户端存根接收到消息后，将其反序列化，然后将结果返回给客户端程序。

一个端口对应一个协议的服务

* 序列化：将对象转换为二进制形式（字节数组），主要用于网络传输、数据持久化等
* 反序列化：将从网络、磁盘等读取的字节数组还原成原始对象，主要用于对网络传输对象的解码

## 软件系统-分布式

### **Raft算法**

Paxos算法是早期分布式算法，较难理解和实现

分布式系统节点数据强一致性算法

导致数据不一致的可能原因：节点故障、网络延迟、消息丢失

三种角色：

​                ● Leader：处理客户端请求（所有读写操作），以日志形式存储

​                ● Follower：接收Leader数据和命令，同步数据和备份

​                ● Candidate：没有Leader心跳后发起选举，获得过半数投票后成为Leader

当日志被大多数节点确认后，Leader才提交返回给客户端，并通知Follower提交

强一致性：总是有多数节点保持最新的状态

MySQL主从复制架构：主库写，从库读。

最终一致性，读到数据可能有延迟，但最终总会一致；主库挂了后不是自动切换

### **CAP**

不可能三角

​                ● Consistency 一致性：系统总是最新的状态

​                ● Availability 可用性：系统总能返回请求（可能不返回最新的）

​                ● Partition Tolerance 分区容忍性：系统某分区网络不可达也能提供服务

实际工程中P不可避免，一般在C/A中权衡

最终一致性 & 弱一致性 & 强一致性

弱一致性不保证最终数据会一致

在对一致性要求没有那么极致的场景下，一般是BASE（Basically Available, Soft state（中间状态）, Eventually consistency）用最终一致换可用性

ACID强调的是强一致性，这也是SQL和NoSQL的区别

NoSQL相比关系型数据库更容易扩展

### 分布式事务

分布式锁：仅防止多个节点同时修改同一份数据，保证同一时刻只有一个节点进行写操作（常用Redis分布式锁和Zookeeper分布式锁。RedLock一致性不强）

分布式事务难以实现：网络不可靠、节点故障、资源锁定多、性能开销大

2PC(Two-Phase Commit), 3PC(Three-Phase Commit) 都需要多次网络延迟开销大

Quorum机制：超过半数节点才有效

分布式ID保证全局唯一、高可用（防止性能瓶颈）、大致有序（方便分库分表）、无中心化依赖

​                ● 数据库自增ID：扩展性差

​                ● UUID (Universal Unique ID)：无序且太长

​                ● 雪花算法：基于时间戳、机器ID、序列号，64位，推特开源。需要分配机器ID

缓存

​                ● Cache Penetration（缓存穿透）：查不存在的数据导致频繁访问数据库

​                ○ 布隆过滤器 || 缓存不存在结果

​                ● Cache Breakdow（缓存击穿）：某个热点数据失效时有大量并发请求打到数据库

​                ○ 热点key提前刷新

​                ● Cache Avalance（缓存雪崩）：大量缓存数据在同一时间失效

​                ○ 过期时间随机化

半同步复制：主节点写操作至少等待一个副本确认后再返回

脑裂：因网络分区等原因出现多个主节点

### **Zookeeper**

开源分布式协调服务：服务注册中心、分布式锁、配置管理等中间件、保证强一致性和可用性，但性能有限

过期超时、自动续期、唯一标识都是好文明

## 其他后端组件-大数据

Hadoop非常擅长处理非结构化数据，比如文本文档、日志文件、图像、音频和视频等，使用HDFS和Map/Reduce。也可以处理结构化数据（关系型数据库的表格）和半结构化数据（XML/JSON）。Hadoop适合批处理和大规模数据分析，响应时间较长。

Map/Reduce: 分而治之

* Map映射：减少数据规模，就近分配节点，提供并行计算
* Reduce化简：汇总结果

> Hadoop生态和MySQL/MongoDB/Redis的区别主要在应用场景的不同：离线 vs. 在线。响应实时性的差异。

Zookeeper: 分布式协调服务，负责管理协调分布式系统中的节点

* Kafka：LinkedIn开源的分布式消息队列系统，构建实时数据管道和流处理应用，用于异步通信、解耦系统、流量削峰等。发布订阅设计模式
* RocketMQ：Alibaba开源的分布式消息队列系统，专注于高可用、高性能、事务。吞吐量略逊于Kafka，但可靠性更好

ELK：用于构建可视化的日志分析管理系统

* Elasticsearch：实时搜索和分析大规模数据
* Logstash：数据采集和转换
* Kibana：数据可视化和仪表盘

Ceph：分布式存储系统，提供对象存储、块存储和文件存储。算是Hadoop的竞品。

## 其他后端组件-Git

Git的版本管理模型是围绕快照（snapshot）构建的。每次提交（commit）都会记录当前所有文件的快照，包括文件内容和目录结构的状态。

clone, init, status, add, commit, log, checkout, pull

* git merge：保留分叉所有历史，git树上显示先分叉再合并
* git rebase：原分支应用所有分叉分支的修改，git树上只有一条分支

## 其他后端组件-消息队列

主要是RocketMQ和Kafka

为什么会出现消息队列？解耦消息发送方和接收方

实现异步通信、削峰填谷、可靠传递（消息队列负责持久化、有序、重试确认）

消息队列服务也需要部署分布式提高可用性

处理消息的称为Broker，Kafka不同topic消息存储在不同broker上（Partition，每个Partition有一个Leader和多个Follower）；RocketMQ的Broker分为Master和Slave，Slave只负责同步数据

RabbitMQ：近20年前的产物，处理大流量和大并发时受限（kafka和rocketmq的qps都可以达到10w+），Exchange负责路由分发，Queue负责存储

Kafka核心概念：

​                ● Event：实际的消息

​                ● Broker：服务器节点

​                ● Topic：消息分类

​                ● Partition：Topic的物理分片，Offset为唯一编号

​                ● Replica：每个Partition有多个Replica，分布在不同Broker中，分为Leader（负责读写）和Follower

KStream 无边界数据流

Append-only

队列类型：

​                ● 延时队列：在指定延迟时间后才被消费

​                ● 死信队列：存放异常消息

​                ● 优先级队列

## 其他后端组件-Kubernetes

etcd(/etc + distributed): 一致且高可用的分布式键值存储，作为K8S的后台数据库，通常部署奇数个。完全复制，每秒一万次写入，gRPC调用，raft算法实现强一致。

## 其他后端组件-SRE

故障诊断和质量保障：Metric, Trace, Log, Profile, Event

P50, P95, P99：统计学概念，将所有数从小到大排序，有x%的值小于Px的值

告警等级：通知，告警，故障（oncall）

在 devops 和 sre 之前由 sysadmin/op 负责手工系统运维，所以运营和开发会打架

SRE 可以视为 DevOps 的一种具体实现

SRE 由软件工程师组成，自动化运维工作，有一半时间实际投入自动化运维系统的开发

SRE bar相当高：一般 programmer 技能 + system engineering + 24h oncall

一次 on-call shift 为 8-12 小时，期间应该最多两次事件。因为要留足够多的时间用于快速准确解决事件、收拾残局、恢复服务、事后检查。过度劳累反而不会提高 SRE 长期效率

对于事后检查，documentation 极其重要。blame-free culture 很重要，对事不对人。

一个可用性目标为 99.99% 的系统一年允许停机最多 52.56 min，对于可用性要求高的系统，通常会有多个相互隔离的系统同时运行，使得始终部分可用



## 待分类

每个线程有自己的寄存器（程序计数器）和运行堆栈，但共享代码和数据空间

一个线程崩溃可能导致整个进程崩溃

进程资源：虚拟内存、文件句柄、信号量

匿名管道只能用于具有亲缘关系的进程间通信

自旋锁：线程不阻塞而是忙等待直到获取到锁（通过CPU的CAS函数实现，无上下文切换，适合锁持有时间很短的场景）

银行家算法：分配资源前判断进程不会导致死锁（放贷信用）

​                ● 编译型语言：先编译成机器码生成可执行文件，再运行

​                ● 解释型语言：逐行解释执行，不生成可执行文件

乐观锁通过数据版本处理冲突，适合读多写少；悲观锁通过加锁，适合写多场景

程序分段：栈、堆、代码、数据（全局变量、静态变量）

copy on right（写时复制）：父子进程正常只复制页表，写时才复制物理内存

内存分配有阈值：小于阈值从堆中分配，大于阈值从文件映射区域分配

一般都是LRU（最近最久未访问）

poll/select 都需要复制到内核态，都是线性结构，都是遍历

传统文件传输（4次上下文切换）；零拷贝（2次上下文切换）合并磁盘读取和网络发送

Redis值类型：string, list, set, zset, hash，键始终是字符串

Redis有序链表使用了跳表（多层有序链表，实际复杂度O(logN)）

B+树存储数据相比跳表，需要的磁盘io更小（跳表层数会过高）

mysql保证原子性的方式：先写undolog再提交事务

间隙锁：mysql在可重复读隔离级别下防止幻读的锁

堆：特殊树形数据结构（大根堆 & 小根堆），可用于实现优先队列

ELK（日志管理和系统可观测性数据的处理和分析）：

​                ● ElasticSearch：存储、索引、搜索日志数据

​                ● Logstash：从各种来源收集日志数据

​                ● Kibana：提供数据可视化和仪表盘

Redis哨兵模式：监控主服务器是否正常运行，向客户端提供主服务器地址，出问题时选择服务器升级

Mysql中int(10)为显示宽度（补前置零），固定4字节，宽度超限不截断

innodb的行级锁有共享锁（所有事务读）和排他锁（一个事务读写）两种

Mysql中前缀索引主要由B树实现

B+树在插入、删除、更新后会自动重新平衡

mysql redolog持久性（断电恢复），undolog原子性（事务回滚和MVCC），binlog（数据备份和主从复制）relay log（slave拷贝binlog日志）

​                ● redolog内容：事务ID，页ID，偏移量；修改后数据，结合Write-Ahead Logging保证在磁盘顺序写的持久化。完成后数据值

​                ● undolog：事务开始时数据状态，原子性回滚。开始前数据值

​                ● binlog：记录sql语句，用于主从复制，在服务器层，没法记录未刷盘脏页

 

CPU爆了的常见原因：无限循环、后台进程、高流量、资源密集型应用（视频编辑、游戏、科学模拟）、内存不足（CPU在管理虚拟内存）、并发进程、繁忙等待、正则计算、病毒

 

一般的短连接每次都要三次握手和四次挥手，长连接（请求头为keep-alive）则可以服用TCP链接

CDN 从权威域名服务器拿到cdn域名，再到load balancer域名，再到具体CDN服务器域名

 

提高程序性能：

​                ● I/O优化：零拷贝技术，

 

GC是很多Go服务的性能瓶颈，本身也在优化，有时升级Go版本就能解决

​                ● Go1.3前STW一次数百毫秒

​                ● Go1.5变成三色标记法和写屏障（插入删除时保证黑色对象不直接引用白色对象）

​                ○ 只应用在堆上，栈写频繁还是要STW（10-100ms）

​                ● Go1.8引入混合写屏障：GC期间所有栈上对象为黑色，几乎消除了STW

扫描比回收更消耗CPU

扫描时机：

​                ● 堆内存达到阈值（可改触发基数和触发条件）

​                ● 定时触发

​                ● 手动触发

火焰图中gcBgMarkWorker占CPU超过10%一般就需要优化了

GC优化方向：

​                ● 减少堆对象的分配（GC时要递归扫描所有对象，栈会在函数结束后自动回收）

​                ○ 小结构体用值而不是指针

​                ○ 用匿名函数替代闭包（会延长局部变量生命周期）

​                ● bigcache存储大对象（[]byte类型只会扫描一次）

​                ● 用池化优化内存分配

​                ● 用原子操作选择性替代锁

​                ● 慎用深度拷贝和反射

​                ● 将任务主动打散分配到不同机器中

​                ● 控制回报大小和数据优先级

对外接口的平均耗时最靠控制在100ms以内，可靠性控制在99.99%

常见的编解码方式：sonic, pb, json, yaml

sonic 是字节开源的高性能golang json编解码库，比官方快2-5倍，且接口兼容，大量使用零拷贝技术，令人惊艳的卓越

字符串拼接性能：strings.Builder = strings.Join > + > fmt.Sprintf

Golang官方性能分析工具：

​                ● pprof：profiling，分析CPU占用，内存分配，goroutine信息，阻塞情况，可以生成火焰图

​                ● trace：全链路事件追踪工具，查看并发、调度过程、时序信息，生成时间线



图数据库常见应用场景：社交网络、推荐系统、知识图谱、网络拓扑、欺诈检测、权限管理

Neo4j（开源且流行）：Node + Edge/Relationship，Cypher（类似SQL）

MongoDB面向文档的开源bson数据库，适合存储结构化或者半结构化数据

InfluxDB：开源时间序列数据库

Firebase：实时数据同步的 NoSQL数据库

列式存储数据库Cassandra，压缩效率更高，适合大数据分析（执行聚合操作）

OWASP (Open Web Application Security Project)：开源组织帮助列举常见的安全问题

CSP (Content Security Policy)：只从可信域加载JS/css等资源，降低XSS攻击风险

常见的云服务（以AWS为例）：

​                ● Route 53：DNS服务，将用户请求路由到互联网应用中

​                ● SES (Simple Email Service)：邮件发送和接收服务

​                ● EC2 (Elastic Compute Cloud)：虚拟服务器

​                ● VPC (Virtual Private Cloud)：隔离网络环境

​                ● S3 (Simple Storage Service)：数据库

Service Mesh：微服务架构的基础设施层，将网络通信从应用代码中抽离出来

SOA 相比 Microservice 的粒度通常较粗，可以实现完整的应用功能

12 Factor App：现代 app 构建方法论

​                ● Codebase

​                ● Dependencies

​                ● Config

​                ● Backing Services

​                ● Build, Release, Run

​                ● Processes

​                ● Port Binding

​                ● Concurrency

​                ● Disposability：可以快速启动、水平扩展，优雅终止

​                ● Dev/Prod Parity：不同开发环境尽量一致

​                ● Logs

​                ● Admin Processes

为软件工程服务的设计模式：

​                ● 单例模式：一个类只有一个实例，并提供一个全局访问点（常用于数据库连接池）

​                ● 工厂模式：创建对象接口，由子类决定实例化哪个类（多态）

​                ● 建造者模式：将构建过程和组件分离

​                ● 原型模式：复用现有实例

​                ● 观察者模式：事件处理器 watcher

​                ● 装饰器模式：数据流处理中动态为数据流添加功能，缓冲、加密、压缩

​                ● 适配器模式：兼容

​                ● 代理模式：配置代理

CQRS（Command Query Responsibility Segregation）：命令查询职责分离（读写分离）

DDD (Domain-Driven Design)：将系统按业务模型组织

代码分类：业务代码、胶水代码（调用或组装，不含复杂逻辑，重点集成测试）、基础设施代码（和底层资源打交道）、配置代码、接口代码、工具代码、中间件代码、测试代码、脚本代码

依赖注入可以通俗地理解为将一个函数或对象所依赖的组件从内部创建转变为通过参数传递进来，解耦业务逻辑和依赖